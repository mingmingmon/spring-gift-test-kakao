# USING_AI.md - AI 활용 문서

## 1. 어떤 질문을 했는가

### Q1. 프로젝트 분석 및 핵심 행동 식별 요청

> "핵심 행동 식별을 해서 project-analysis.md라는 파일을 만들어줘.
> 프로젝트 구조, 계층 구조, 도메인 모델, 엔티티 정보, 사용 가능한 API,
> 프로젝트 내부적으로 이상한 점이나 결함이라고 의심되는 부분도 포함해줘"

- CLAUDE.md의 Step 1(핵심 행동 식별)을 수행하기 위한 사전 작업으로, 프로젝트 전체 분석을 먼저 요청
- 단순히 행동 목록만이 아니라, 프로젝트 구조와 결함까지 포함하도록 범위를 확장

### Q2. TEST_STRATEGY.md 작성 요청

> "지금까지의 내용으로 TEST_STRATEGY.md 작성해줘"

- project-analysis.md의 분석 결과를 기반으로, CLAUDE.md가 요구하는 테스트 전략 문서 작성을 요청

### Q3. 테스트 데이터 격리 전략 심화 요청

> "test_strategy.md에서 테스트 데이터 전략 수립에 대해 조금 더 고민해보자.
> 다시 한 번 검토하고 좀 더 구체적으로 격리 전략을 제안하고 그 이유를 말해줘"

- Claude의 초안이 `@DirtiesContext 또는 @BeforeEach DB 초기화`라고만 적혀 있어 구체성이 부족하다고 판단
- 4가지 격리 전략 후보(DirtiesContext, Repository deleteAll, SQL TRUNCATE, 고유 데이터)를 비교 분석하도록 요청

### Q4. main 패키지 수정 없이 격리 구현 요청

> "DatabaseCleaner는 main 패키지에서 코드를 추가해야 되는거야?
> test 패키지 내부에서만 테스트 코드를 작성하는 경우만 가능하다고 한다면
> 어떻게 다른 방법을 선택해야 돼?"

- Claude가 제안한 `@Component DatabaseCleaner`가 main 패키지에 테스트 전용 코드를 넣는 문제를 지적
- 제약 조건(test 패키지 내부에서만 해결)을 명시하고 대안을 요청

### Q5. 비정상 입력 시나리오 추가 요청

> "오류 작동에 대해서 조금 더 다양한 케이스를 추가해보고 싶어.
> 예를 들어 값이 null이거나 음수, 0일 수 있는 거잖아?
> 이 예시처럼 해당 프로그램을 사용자가 행위를 했을 때 발생할 수 있는
> 더 다양한 오류 상황에 대해서 테스트할 수 있는 시나리오를 test_strategy.md에 추가해줘"

- 기존 시나리오가 성공 케이스 위주였으므로, 사용자 관점에서 발생 가능한 비정상 입력을 구체적인 예시(null, 음수, 0)와 함께 요청
- Claude가 코드를 분석하여 `Option.decrease(-5)` 시 재고가 증가하는 명확한 버그를 발견하는 계기가 됨

### Q6. 시나리오 구조 변경 + 입력 외 예외 상황 추가 요청

> "지금은 정상 시나리오 / 비정상 시나리오 이렇게 나눴는데
> 이렇게 작성하지 말고 도메인별로 나눈 다음에 성공 시나리오 / 실패 시나리오 이렇게 나눠주고
> 꼭 입력에 대한 예외가 아니더라도 발생할 수 있는 예외 상황을 더 추가해서 작성해줘"

- Q5로 추가된 비정상 시나리오가 기존 정상 시나리오와 분리되어 있어, 도메인별로 재구성하도록 요청
- 입력값 문제뿐 아니라 시스템 상태에 따른 예외(존재하지 않는 리소스, 헤더 누락, 요청 바디 없음 등)도 포함하도록 범위를 확장
- 이 요청으로 테스트 클래스 구조와 메서드 매핑도 함께 업데이트됨

### Q7. TEST_STRATEGY.md 기반 테스트 코드 작성 요청

> "TEST_STRATEGY.md 기반으로 테스트 코드 작성해줘. claude.md의 스텝 4도 참고해줘"

- CLAUDE.md Step 4(RestAssured 인수 테스트 작성)에 따라 21개 시나리오를 코드로 구현하도록 요청
- Claude가 구현 계획을 제시하고 승인 후 코드를 작성함

### Q8. 실패 시나리오의 기대값 통일 요청

> "실패 시나리오쪽이 몇 개가 '요청이 실패하거나, ~~한다' 이렇게 되어있는 경우가 있어.
> 실패 시나리오라면 모두 요청이 실패하는 것이 결과가 되도록 수정해줘"

- TEST_STRATEGY.md에서 F-CAT-1, F-PRD-3, F-PRD-4, F-GIFT-3, F-GIFT-4, F-GIFT-7의 Then 절이 "실패하거나 ~한다", "성공/실패 여부를 확인한다"처럼 모호하게 작성되어 있음을 지적
- 실패 시나리오라면 기대 결과가 명확히 "요청이 실패한다"여야 한다는 기준을 제시

### Q9. 인수 테스트 작성 방식에 대한 논의

> "좋은 인수테스트라면 기대하는 바를 명확히 테스트 코드로 작성하고 테스트를 실패시키는 것을 유도하는게 나아?
> 아니면 main 코드를 통과하게 테스트 코드를 작성하고 이상한 상태인데 통과하는 부분에 대해서 리포트를 적어서 수정하도록 하는게 나아?"

- Claude는 처음에 접근 B(현재 행동 기록 → 리포트)를 제안했으나, 후속 질문을 통해 접근을 재검토함
- "null이 저장되는 걸 허용하고 테스트를 통과시키면 버그를 보호하는 것 아닌가?"라는 반론에 Claude가 동의
- 최종적으로 **명백한 결함에 대해서는 접근 A**(기대하는 바를 명확히 작성 → 테스트 실패 유도)를 채택

### Q10. 성공 시나리오도 올바른 행동을 기대하도록 전환 요청

> "@RequestBody가 없어서 문제가 생기는 것들 중에 일부는 null을 저장시키는걸 허용했는데,
> 이 부분 전부 다 오류 나게 test_strategy 바꿔줘"

- Q9에서 실패 시나리오(F-CAT-1, F-GIFT-3 등)만 접근 A로 전환했었는데, 성공 시나리오(S-CAT-1, S-CAT-2)도 여전히 null을 허용하고 있음을 지적
- 성공 시나리오도 "요청한 값이 정확히 저장/반환되어야 한다"는 올바른 기대로 전환하도록 요청

### Q11. 버그 리포트 작성 요청

> "테스트 코드가 일부 통과가 안되는 것들이 있을거야. 그것들을 목록화 해서 main에서 어느 파일의 어느 코드가 문제여서 발생한 버그인지, 어떻게 하면 수정할 수 있는지 버그 제보 리포트를 BUG_REPORT.md 파일에 적어서 만들어줘"

- 테스트 실패 목록을 결함 수정 가이드로 문서화하도록 요청
- 테스트 클래스별 통과/실패 현황 → 실패 테스트별 원인 분석 및 수정 방법 구조로 작성

---

## 2. Claude의 제안을 어떻게 검증/수정했는가

### 2.1 핵심 행동 목록 수정

Claude는 최초 6개의 핵심 행동을 제안했다:

| # | Claude 원안 | 최종 |
|---|------------|------|
| 1 | 카테고리 생성 | 유지 |
| 2 | 상품 생성 | 유지 |
| 3 | 상품 조회 | 유지 |
| 4 | 선물하기 (재고 차감) | 유지 |
| 5 | 선물하기 실패 (재고 부족) | 유지 |
| 6 | 존재하지 않는 리소스 참조 시 실패 | **삭제** |

**수정 이유**: 6번 항목("존재하지 않는 리소스 참조 시 실패")은 별도의 핵심 행동으로 분리하기보다, 각 시나리오의 실패 케이스 안에서 자연스럽게 다루는 것이 적절하다고 판단하여 제거. 예를 들어 "존재하지 않는 카테고리로 상품 생성 실패"는 상품 생성 시나리오의 실패 케이스로 포함됨.

### 2.2 테스트 데이터 격리 전략 수정 (2회)

**1차 수정 - 격리 전략 구체화**

Claude 초안은 격리 전략을 한 줄로만 언급했다:
> `@DirtiesContext 또는 @BeforeEach에서 DB 초기화`

이를 4가지 후보 전략으로 비교 분석하도록 요청했고, Claude는 전략 C(SQL TRUNCATE + DatabaseCleaner)를 제안했다.

**2차 수정 - main 패키지 수정 금지 제약 추가**

Claude의 DatabaseCleaner 제안은 `@Component`로 main 패키지에 배치하는 구조였다. 이는 테스트 전용 코드가 프로덕션 코드에 섞이는 문제가 있어, "test 패키지 내부에서만 해결해야 한다"는 제약을 추가했다.

Claude는 두 가지 대안을 제시했고, 최종적으로 더 단순한 방식을 선택했다:

| 대안 | 설명 | 최종 |
|------|------|------|
| `@TestConfiguration` + DatabaseCleaner 클래스 | test 패키지에 별도 클래스 + Bean 설정 | 탈락 (보일러플레이트 과다) |
| BaseAcceptanceTest + `@BeforeEach` 직접 TRUNCATE | 부모 클래스에서 JdbcTemplate으로 직접 처리 | **채택** |

**채택 이유**: 엔티티 5개, 테스트 클래스 3개 규모에서 JPA 메타모델 자동화나 별도 클래스 분리는 오버엔지니어링. 부모 클래스 한 곳에서 테이블 5개를 TRUNCATE하는 것이 가장 명확하고 유지보수가 쉬움.

### 2.3 시나리오 구조 변경 및 확장

**구조 변경 요청**

Claude의 초안은 시나리오를 "정상 시나리오(2.1~2.5) / 비정상 입력 시나리오(2.6~2.8)"로 나누었다. 이를 도메인별(카테고리 / 상품 / 선물하기)로 재구성하고, 각 도메인 안에서 성공/실패를 나누도록 요청했다.

| 항목 | Claude 초안 | 최종 |
|------|-----------|------|
| 분류 기준 | 정상/비정상 | **도메인별** (카테고리, 상품, 선물하기) |
| 하위 구분 | 없음 (섞여 있음) | 도메인 내 **성공/실패** 분리 |

**변경 이유**: 도메인별로 나누면 테스트 클래스 구조와 1:1로 대응되어, 시나리오 → 코드 추적이 쉬움.

**시나리오 확장 요청**

입력값 검증(null, 음수, 0) 외에도, 시스템 상태에 따라 발생할 수 있는 예외 상황을 추가하도록 요청했다.

Claude가 코드를 분석하여 추가로 발견한 시나리오:

| ID | 시나리오 | 발견 방법 |
|----|---------|----------|
| S-CAT-2 | 여러 카테고리 생성 후 전체 조회 | 목록 조회의 정확성 검증 필요성 |
| S-PRD-2 | 서로 다른 카테고리에 상품 각각 생성 | 카테고리 연결 정확성 |
| S-GIFT-2 | 연속 선물 누적 차감 | 단일 차감만으로는 누적 정확성을 보장할 수 없음 |
| S-GIFT-3 | 재고 전부 소진 경계값 | 기존 2.5에서 분리 (성공 단계와 실패 단계를 독립 시나리오로) |
| F-GIFT-7 | 존재하지 않는 받는 회원에게 선물 | FakeGiftDelivery가 수신자(getTo)를 조회하지 않는 코드 분석에서 발견 |
| F-GIFT-9 | 요청 바디 없이 선물하기 | @RequestBody 필수 여부 검증 |

특히 **F-GIFT-7**은 Claude의 코드 분석에서 나온 발견이다: `FakeGiftDelivery.deliver()`가 `gift.getFrom()`(보내는 사람)만 조회하고 `gift.getTo()`(받는 사람)은 조회하지 않아, 존재하지 않는 수신자에게 선물이 성공하는 결함을 가시화할 수 있다.

**최종 시나리오 규모 변화**

| 항목 | 초안 | 최종 |
|------|------|------|
| 성공 시나리오 | 3개 | 7개 |
| 실패 시나리오 | 6개 | 14개 |
| 합계 | 9개 | **21개** |

### 2.4 테스트 코드 구현 과정에서의 발견과 수정

Claude가 TEST_STRATEGY.md의 21개 시나리오를 RestAssured 기반 인수 테스트로 구현했다.

#### 첫 실행 결과: 21개 중 5개 실패

| 실패 테스트 | 에러 내용 |
|-----------|----------|
| CategoryAcceptanceTest - S-CAT-1 (1개) | `Expected: 음료, Actual: null` — name이 바인딩되지 않음 |
| ProductAcceptanceTest - S-PRD-1, S-PRD-2, F-PRD-3, F-PRD-4 (4개) | `Expected status code <200> but was <500>` — 모든 POST가 500 |

#### 실패 원인 분석: @RequestBody 누락의 실제 영향

project-analysis.md에서 이미 `@RequestBody` 누락을 [심각] 결함으로 식별했지만, 분석 단계에서는 "JSON 바인딩이 안 될 가능성"이라고만 예상했다. 실제 테스트 실행으로 드러난 영향은 더 심각했다:

1. `@RequestBody`가 없으면 Spring은 `@ModelAttribute` 방식으로 form parameter 바인딩을 시도한다
2. `@ModelAttribute` 바인딩은 DTO의 **setter 메서드**를 통해 값을 주입한다
3. 그런데 `CreateCategoryRequest`, `CreateProductRequest`에는 **getter만 있고 setter가 없다**
4. 따라서 어떤 방식(JSON이든 form param이든)으로 요청을 보내도 **모든 필드가 기본값(null/0)으로 남는다**

구체적 결과:
- **Category**: `name`이 항상 null → name=null인 카테고리가 그대로 DB에 저장됨 (200 OK)
- **Product**: `categoryId`(Long)가 항상 null → `categoryRepository.findById(null)` → `IllegalArgumentException` → 500 에러
- 즉, **Category/Product 생성 API가 완전히 깨진 상태**였다

#### 해결: 테스트 assertion을 현재 시스템의 실제 행동에 맞게 수정

CLAUDE.md 원칙 "테스트는 현재 시스템의 실제 행동을 기록한다"에 따라, 코드를 고치는 대신 **테스트의 기대값을 실제 행동에 맞게 수정**했다:

| 도메인 | 수정 전 assertion (예상 행동) | 수정 후 assertion (실제 행동) |
|--------|--------------------------|--------------------------|
| Category S-CAT-1 | `name == "음료"`, 후속 조회 name 확인 | `name == null`, 후속 조회에서도 **name=null** 확인 |
| Category S-CAT-2 | name 값 확인 | name 검증 제거, **레코드 개수(3개)만** 확인 |
| Product S-PRD-1 | `statusCode(200)` + 상품 정보 확인 | `statusCode(500)` + 후속 조회에서 **상품 0개** 확인 |
| Product S-PRD-2 | `statusCode(200)` 2번 + 상품 2개 확인 | `statusCode(500)` 2번 + **상품 0개** 확인 |
| Product F-PRD-3 | `statusCode(200)` + 음수 가격 저장 확인 | `statusCode(500)` + **상품 미생성** 확인 |
| Product F-PRD-4 | `statusCode(200)` + 가격 0 저장 확인 | `statusCode(500)` + **상품 미생성** 확인 |

Gift 테스트는 `@RequestBody`가 올바르게 적용되어 있어 12개 전부 원안대로 통과했다.

#### 이 과정의 효과

1. **분석 단계 예측의 검증**: project-analysis.md에서 "결함 가능성"으로 기록한 것이 실제 테스트 실행으로 **확정된 결함**으로 승격되었다
2. **결함의 정확한 범위 파악**: `@RequestBody` 누락이 단순히 "JSON 바인딩 실패"가 아니라, setter 부재와 결합되어 **모든 바인딩 방식이 불가능**함을 발견했다
3. **행동 기반 테스트의 가치 증명**: 테스트가 "코드가 의도대로 동작하는가"가 아닌 "현재 시스템이 실제로 어떻게 동작하는가"를 기록함으로써, 향후 `@RequestBody` 추가 등의 수정 시 **행동 변화를 즉시 감지**할 수 있는 안전망이 됨
4. **리팩터링 보호**: Category/Product 컨트롤러에 `@RequestBody`를 추가하면 기존 테스트가 실패하면서 "행동이 변경되었다"는 신호를 보내게 되어, CLAUDE.md가 목표로 하는 **리팩터링 보호**가 작동함

#### 최종 결과: 21개 전체 통과

| 클래스 | 테스트 수 | 결과 |
|--------|----------|------|
| CategoryAcceptanceTest | 3 | 전체 통과 |
| ProductAcceptanceTest | 6 | 전체 통과 |
| GiftAcceptanceTest | 12 | 전체 통과 |
| **합계** | **21** | **전체 통과** |

### 2.5 실패 시나리오 테스트 방식 전환: "현재 행동 기록" → "기대 행동 명시"

#### Claude의 초기 접근: 현재 행동을 그대로 기록 (접근 B)

Claude는 처음에 CLAUDE.md의 "리팩터링 보호" 원칙을 근거로, 결함이 있는 시나리오도 현재 시스템의 실제 행동을 그대로 테스트에 기록하는 방식을 택했다:

| 테스트 | 현재 시스템의 실제 행동 | Claude 초기 assertion |
|--------|---------------------|---------------------|
| F-CAT-1 (name=null) | null이 그대로 DB에 저장됨 (200 OK) | `statusCode(200)` + `name == null` |
| F-GIFT-3 (quantity=0) | 검증 없이 성공 (재고 불변) | `statusCode(200)` + 재고 불변 |
| F-GIFT-4 (quantity=-5) | 성공 + 재고 10→15 증가 (버그) | `statusCode(200)` + 재고 15 |
| F-GIFT-7 (수신자 미존재) | 수신자 검증 없이 성공 + 재고 차감 | `statusCode(200)` + 재고 7 |

이 방식의 논리: "현재 행동을 고정해야 리팩터링 시 안전망이 된다."

#### 문제 제기: 버그를 테스트가 보호하는 역설

"null이 저장되는 걸 허용하고 테스트를 통과시키면, 테스트가 버그를 보호하는 것 아닌가?"라는 질문을 통해 Claude의 접근을 재검토했다.

핵심 구분:
- **리팩터링으로 바뀔 수 있는 행동** (Service 분리, Repository 변경 등) → 현재 행동을 보호해야 함
- **명백한 버그/결함** (null 저장, 음수 수량으로 재고 증가 등) → 보호할 "행동"이 아니라 **고쳐야 할 결함**

#### 최종 결정: 결함 시나리오는 기대 행동을 명시 (접근 A)

명백한 결함에 대해서는 "이렇게 동작해야 한다"를 테스트에 명시하고, 테스트 실패를 통해 main 코드 수정을 유도하는 방식으로 전환했다:

| 테스트 | 수정 후 assertion | 의미 |
|--------|-----------------|------|
| F-CAT-1 | `statusCode(500)` + 카테고리 0개 | null 카테고리는 저장되지 않아야 한다 |
| F-GIFT-3 | `statusCode(500)` + 재고 불변 | 수량 0 선물은 실패해야 한다 |
| F-GIFT-4 | `statusCode(500)` + 재고 10 유지 | 음수 수량 선물은 실패해야 한다 |
| F-GIFT-7 | `statusCode(500)` + 재고 불변 | 존재하지 않는 수신자에게 선물은 실패해야 한다 |

#### 이 방식의 효과

- **테스트 통과** = 시스템이 올바르게 동작하는 부분
- **테스트 실패** = main 코드에 수정이 필요한 결함
- 테스트 실패 목록이 곧 **수정해야 할 결함 목록**이 됨

### 2.6 성공 시나리오까지 "올바른 행동 기대"로 전환 및 버그 리포트 작성

#### 성공 시나리오 전환

2.5에서 실패 시나리오(F-CAT-1, F-GIFT-3 등)만 접근 A로 전환했으나, 성공 시나리오(S-CAT-1, S-CAT-2)는 여전히 null 저장을 허용하는 상태였다. 이를 지적하여 성공 시나리오도 올바른 행동을 기대하도록 전환했다:

| 테스트 | 변경 전 | 변경 후 |
|--------|--------|--------|
| S-CAT-1 | `.param("name", "음료")` + `name == null` 허용 | `.body(Map.of("name", "음료"))` + `name == "음료"` 기대 |
| S-CAT-2 | `.param()` + name 검증 없음 | `.body(JSON)` + 각 name `notNullValue()` 기대 |
| S-PRD-1 | `.param()` + `statusCode(500)` 허용 | `.body(JSON)` + `statusCode(200)` + name, price 값 일치 기대 |
| S-PRD-2 | `.param()` + `statusCode(500)` 허용 | `.body(JSON)` + `statusCode(200)` 기대 |

모든 테스트가 form parameter 방식(`.param()`)에서 JSON body 방식(`.contentType(JSON).body(Map.of(...))`)으로 변경되었다. 이는 테스트가 "올바른 요청 방식"으로 보내되, main 코드의 @RequestBody 누락이 원인으로 실패하게 만든다.

#### TEST_STRATEGY.md 방침 변경

| 항목 | 변경 전 | 변경 후 |
|------|--------|--------|
| 섹션 5.2 | "테스트는 현재 시스템의 실제 행동을 기록한다" | "테스트는 올바른 행동을 기대한다" |
| 시나리오 하단 주석 | "현재 시스템이 어떻게 행동하는가" | "시스템이 어떻게 행동해야 하는가" |

#### 버그 리포트 작성

테스트 실패 목록을 BUG_REPORT.md로 문서화했다. 구조:

1. **테스트 클래스별 통과/실패 현황** — 21개 중 13개 통과, 8개 실패
2. **실패 테스트별 원인 분석 및 수정 방법** — 4개 결함 (BUG-1~4)

| BUG ID | 결함 | 실패 테스트 | 수정 대상 파일 |
|--------|------|-----------|--------------|
| BUG-1 | @RequestBody 누락 | S-CAT-1, S-CAT-2, S-PRD-1, S-PRD-2 | CategoryRestController.java, ProductRestController.java |
| BUG-2 | name=null 저장 허용 | F-CAT-1 | CategoryService.java |
| BUG-3 | 음수/0 수량 허용 | F-GIFT-3, F-GIFT-4 | Option.java |
| BUG-4 | 수신자 검증 누락 | F-GIFT-7 | FakeGiftDelivery.java |
